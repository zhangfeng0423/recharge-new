#!/usr/bin/env tsx

/**
 * Database Schema Builder & Validator using Zod
 *
 * Defines database schemas using Zod, validates them, and generates
 * TypeScript types, SQL DDL, RLS Policies, RPC Functions, and ORM schemas.
 */

import { z } from "zod";
import { Command } from "commander";
import fs from "fs/promises";
import path from "path";

// Zod schema for a database column
const columnSchema = z.object({
  type: z.enum(["string", "text", "number", "boolean", "date", "json", "uuid"]),
  primaryKey: z.boolean().optional(),
  unique: z.boolean().optional(),
  nullable: z.boolean().optional().default(false),
  default: z.any().optional(),
  references: z
    .object({
      table: z.string(),
      column: z.string(),
    })
    .optional(),
});

// Zod schema for a database table
const tableSchema = z.object({
  columns: z.record(z.string(), columnSchema),
  indexes: z
    .record(
      z.string(),
      z.object({
        columns: z.array(z.string()).min(1),
        unique: z.boolean().optional(),
      }),
    )
    .optional(),
  // (New) Define the column used for RLS ownership.
  rlsOwner: z.string().optional(),
});

// Zod schema for the entire database
const databaseSchema = z.record(z.string(), tableSchema);

// Infer TypeScript types from Zod schemas
type Column = z.infer<typeof columnSchema>;
type Table = z.infer<typeof tableSchema>;
type Database = z.infer<typeof databaseSchema>;

// --- Schema Loading ---
async function loadSchemaFromFile(filePath: string): Promise<Database> {
  const absolutePath = path.resolve(filePath);
  try {
    // Invalidate require cache to pick up changes
    delete require.cache[require.resolve(absolutePath)];
    const schemaModule = await import(absolutePath);
    const schema = schemaModule.default || schemaModule.mySchema;

    if (!schema) {
      throw new Error(
        `Could not find a schema export (expected 'default' or 'mySchema') in ${filePath}`,
      );
    }

    // Validate the loaded schema against the Zod definition
    databaseSchema.parse(schema);
    console.log(`✅ Schema loaded and validated from ${filePath}`);
    return schema as Database;
  } catch (error) {
    console.error(
      `❌ Error loading or validating schema from ${absolutePath}:`,
    );
    if (error instanceof z.ZodError) {
      console.error(error.format());
    } else {
      console.error(error);
    }
    process.exit(1);
  }
}

// --- Generators ---

class SchemaGenerator {
  constructor(private dbSchema: Database) {}

  generateTypes(): string {
    let typeDefs = `// Generated by schemaValidator.ts\n\n`;
    for (const tableName in this.dbSchema) {
      const columns = this.dbSchema[tableName].columns;
      const typeName = this.toPascalCase(tableName);
      typeDefs += `export interface ${typeName} {
`;
      for (const columnName in columns) {
        const column = columns[columnName];
        const tsType = this.mapZodToTsType(column.type);
        const optional = column.nullable ? "?" : "";
        typeDefs += `  ${columnName}${optional}: ${tsType};\n`;
      }
      typeDefs += `}

`;
    }
    return typeDefs;
  }

  generateSqlDdl(): string {
    let ddl = ` -- Generated by schemaValidator.ts\n\n`;
    ddl += `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";\n\n`;

    for (const tableName in this.dbSchema) {
      const table = this.dbSchema[tableName];
      ddl += `CREATE TABLE IF NOT EXISTS public.\"${tableName}\" (\n`;
      const columnDefs = [];
      const constraints: string[] = [];

      for (const columnName in table.columns) {
        const column = table.columns[columnName];
        let colDdl = `  \"${columnName}\" ${this.mapZodToSqlType(column.type)}`;
        if (column.primaryKey) colDdl += " PRIMARY KEY";
        if (column.unique) colDdl += " UNIQUE";
        if (!column.nullable) colDdl += " NOT NULL";
        if (column.default !== undefined)
          colDdl += ` DEFAULT ${column.default}`;
        columnDefs.push(colDdl);

        if (column.references) {
          constraints.push(
            `  FOREIGN KEY (\"${columnName}\") REFERENCES public.\"${column.references.table}\"(\" ${column.references.column}\") ON DELETE CASCADE`,
          );
        }
      }

      ddl += [...columnDefs, ...constraints].join(",\n");
      ddl += `\n);

`;

      if (table.indexes) {
        for (const indexName in table.indexes) {
          const index = table.indexes[indexName];
          const unique = index.unique ? "UNIQUE " : "";
          const columns = index.columns.map((c) => `"${c}"`).join(", ");
          ddl += `CREATE ${unique}INDEX IF NOT EXISTS "${indexName}" ON public.\"${tableName}\"(${columns});\n`;
        }
        ddl += "\n";
      }
    }
    return ddl;
  }

  generateRlsPolicies(): string {
    let rls = `-- Generated by schemaValidator.ts\n\n`;
    const tablesWithRls = Object.entries(this.dbSchema).filter(
      ([_, table]) => !!table.rlsOwner,
    );

    if (tablesWithRls.length === 0) {
      return "-- No tables with 'rlsOwner' found. No RLS policies generated.\n";
    }

    rls += `-- Enabling RLS for tables...\n`;
    for (const [tableName, _] of tablesWithRls) {
      rls += `ALTER TABLE public.${tableName} ENABLE ROW LEVEL SECURITY;\n`;
    }
    rls += "\n";

    for (const [tableName, table] of tablesWithRls) {
      const ownerColumn = table.rlsOwner!;
      rls += `
-- RLS Policies for ${tableName}
`;
      rls += `DROP POLICY IF EXISTS "Users can view their own ${tableName}" ON public.${tableName};
`;
      rls += `CREATE POLICY "Users can view their own ${tableName}" ON public.${tableName} FOR SELECT USING (auth.uid() = "${ownerColumn}");

`;
      rls += `DROP POLICY IF EXISTS "Users can insert their own ${tableName}" ON public.${tableName};
`;
      rls += `CREATE POLICY "Users can insert their own ${tableName}" ON public.${tableName} FOR INSERT WITH CHECK (auth.uid() = "${ownerColumn}");

`;
      rls += `DROP POLICY IF EXISTS "Users can update their own ${tableName}" ON public.${tableName};
`;
      rls += `CREATE POLICY "Users can update their own ${tableName}" ON public.${tableName} FOR UPDATE USING (auth.uid() = "${ownerColumn}");

`;
      rls += `DROP POLICY IF EXISTS "Users can delete their own ${tableName}" ON public.${tableName};
`;
      rls += `CREATE POLICY "Users can delete their own ${tableName}" ON public.${tableName} FOR DELETE USING (auth.uid() = "${ownerColumn}");
`;
    }
    return rls;
  }

  generateRpcFunction(tableName: string): string {
    if (!this.dbSchema[tableName])
      return `-- Table \"${tableName}\" not found in schema.\n`;
    const functionName = `get_${tableName}_analytics`;
    const ownerColumn = this.dbSchema[tableName].rlsOwner || "user_id";
    const numericColumn = Object.keys(this.dbSchema[tableName].columns).find(
      (key) => this.dbSchema[tableName].columns[key].type === "number",
    );

    return `
-- Generated by schemaValidator.ts
-- RPC Function for ${tableName} analytics.
CREATE OR REPLACE FUNCTION ${functionName}(p_user_id uuid)
RETURNS TABLE(total_count bigint, total_sum numeric, last_created_at timestamptz)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
    SELECT
      COUNT(*) AS total_count,
      ${numericColumn ? `SUM("${numericColumn}")` : "0"} AS total_sum, -- Replace with a relevant numeric column if needed
      MAX(created_at) AS last_created_at
    FROM
      public.${tableName}
    WHERE
      "${ownerColumn}" = p_user_id;
END;
$$;
`;
  }

  private toPascalCase(str: string): string {
    return str.replace(/(^\w|-\w)/g, (c) => c.replace("-", "").toUpperCase());
  }

  private mapZodToTsType(type: Column["type"]): string {
    switch (type) {
      case "uuid":
      case "string":
      case "text":
        return "string";
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "date":
        return "Date";
      case "json":
        return "any";
    }
  }

  private mapZodToSqlType(type: Column["type"]): string {
    switch (type) {
      case "uuid":
        return "uuid";
      case "string":
        return "VARCHAR(255)";
      case "text":
        return "TEXT";
      case "number":
        return "INTEGER";
      case "boolean":
        return "BOOLEAN";
      case "date":
        return "TIMESTAMP WITH TIME ZONE";
      case "json":
        return "JSONB";
    }
  }
}

// --- CLI ---
async function main() {
  const program = new Command();
  program.name("schema-validator").description("DB schema tool");

  program
    .command("generate")
    .description("Generate artifacts from a schema file.")
    .argument("<file>", "Path to the Zod schema definition file")
    .option("-t, --type <type>", "Artifact type (types, sql, rls, rpc)", "all")
    .option("--table <tableName>", "Table for RPC function generation")
    .action(async (file, options) => {
      const schema = await loadSchemaFromFile(file);
      const generator = new SchemaGenerator(schema);

      if (options.type === "all" || options.type === "types") {
        console.log(generator.generateTypes());
      }
      if (options.type === "all" || options.type === "sql") {
        console.log(generator.generateSqlDdl());
      }
      if (options.type === "all" || options.type === "rls") {
        console.log(generator.generateRlsPolicies());
      }
      if (options.type === "rpc") {
        if (!options.table) {
          console.error("❌ --table <tableName> is required for --type rpc");
          process.exit(1);
        }
        console.log(generator.generateRpcFunction(options.table));
      }
    });

  await program.parseAsync(process.argv);
}

main().catch((err) => {
  console.error("An unexpected error occurred:", err);
  process.exit(1);
});

export { databaseSchema, SchemaGenerator };
export type { Column, Table, Database };
